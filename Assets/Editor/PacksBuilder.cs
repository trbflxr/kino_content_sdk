using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

// DO NOT EDIT THIS FILE
namespace Editor {
  internal class PacksBuilder {
    private const int TOOL_VERSION = 100;
    private const string FILE_EXT = ".knpp";

    private const int SID_SIZE = 17;

    internal void Build(BuildTarget target, PacksToolCache cache) {
      if (!ValidateMeta(cache, out string error)) {
        Debug.LogError($"Kino: Unable to build packs, validation error: {error}");
        return;
      }

      Debug.Log($"Kino: Build started for '{target}'");

      PacksToolCache.EnsureBuildFolder();

      foreach (var pack in cache.Packs) {
        if (!pack.SelectedToBuild) {
          continue;
        }

        BuildPackBundle(target, cache, pack);
      }
    }

    private void BuildPackBundle(BuildTarget target, PacksToolCache cache, PartPackMeta pack) {
      Debug.Log($"Kino: Processing pack '{pack.PackName}'");

      string packFileName = $"{pack.PackName}{FILE_EXT}";

      string packRootFolder = pack.GetRoot();

      var meta = pack.GetProxyMeta();
      if (meta == null) {
        Debug.LogError($"Kino: Unable to build pack '{pack.PackName}', failed to create metadata");
        return;
      }

      meta.AuthorName = cache.Author.Name;

      if (!SaveProxyMetaToTxt(packRootFolder, meta)) {
        Debug.LogError($"Kino: Unable to build pack '{pack.PackName}', failed to create metadata");
        return;
      }

      AssetDatabase.Refresh();

      var assets = new HashSet<string> {
        Path.Combine(packRootFolder, PartPackMeta.PACK_META_RESERVED_NAME)
      };

      if (!string.IsNullOrWhiteSpace(meta.PackIcon)) {
        assets.Add(meta.PackIcon);
      }

      foreach (var part in meta.Parts) {
        if (string.IsNullOrWhiteSpace(part.FilePath)) {
          Debug.LogWarning($"Kino: Skipped invalid part ({part.Id}) in '{meta.Name}'");
          continue;
        }

        assets.Add(part.FilePath);

        if (!string.IsNullOrWhiteSpace(part.IconPath)) {
          assets.Add(part.IconPath);
        }
      }

      var builds = new[] {
        new AssetBundleBuild {
          assetBundleName = packFileName,
          assetNames = assets.ToArray()
        }
      };

      BuildPipeline.BuildAssetBundles(PacksToolCache.BUILD_DIR, builds, BuildAssetBundleOptions.ForceRebuildAssetBundle, target);

      RunPostBuild(packFileName, cache, pack);
    }

    private void RunPostBuild(string fileName, PacksToolCache cache, PartPackMeta meta) {
      string filePath = Path.Combine(PacksToolCache.BUILD_DIR, fileName);

      if (!File.Exists(filePath)) {
        Debug.LogError($"Kino: Unable to locate pack bundle at '{filePath}'");
        return;
      }

      var fileContent = File.ReadAllBytes(filePath);

      using var fileStream = new FileStream(filePath, FileMode.Create);
      using var writer = new BinaryWriter(fileStream);

      writer.Write(TOOL_VERSION);
      writer.Write(meta.Version);
      writer.Write((int)meta.Type);
      writer.Write(meta.Id);
      writer.Write(cache.Author.SteamId);
      writer.Write(cache.Author.DiscordId);
      writer.Write(fileContent.Length);
      writer.Write(fileContent);
    }

    private bool ValidateMeta(PacksToolCache cache, out string error) {
      error = string.Empty;

      ulong sid = cache.Author.SteamId;
      if (sid == 0 || sid.ToString().Length != SID_SIZE) {
        error = $"Invalid author SteamID: {sid}";
        return false;
      }

      if (cache.Author.DiscordId == 0) {
        error = $"Invalid author DiscordID: {cache.Author.DiscordId}";
        return false;
      }

      if (string.IsNullOrWhiteSpace(cache.Author.Name)) {
        error = $"Invalid author Name: {cache.Author.Name}";
        return false;
      }

      if (cache.Packs.Count == 0) {
        error = "Nothing to build";
        return false;
      }

      foreach (var pack in cache.Packs) {
        if (!pack.SelectedToBuild) {
          continue;
        }

        if (string.IsNullOrWhiteSpace(pack.PackName)
            || string.IsNullOrWhiteSpace(pack.Description)) {
          error = "One of selected to build packs has empty fields";
          return false;
        }

        var regex = new Regex("^[A-Za-z0-9_\\-]+$");
        if (!regex.IsMatch(pack.PackName)) {
          error = "Pack name contains not allowed characters. Allowed characters: [A-Z,a-z,0-9,-,_]";
          return false;
        }

        if (pack.Version <= 0) {
          error = $"Invalid pack version: {pack.PackName} -> {pack.Version}";
          return false;
        }

        if (!pack.ForceValidate()) {
          error = "See warnings above";
          return false;
        }
      }

      return true;
    }

    private bool SaveProxyMetaToTxt(string packRoot, PartPackMeta.Proxy meta) {
      if (string.IsNullOrWhiteSpace(packRoot) || meta == null) {
        return false;
      }

      try {
        string json = JsonUtility.ToJson(meta, true);

        using var stream = new FileStream(Path.Combine(packRoot, PartPackMeta.PACK_META_RESERVED_NAME), FileMode.Create, FileAccess.Write);
        using var writer = new StreamWriter(stream, Encoding.UTF8);
        writer.Write(json);

        return true;
      }
      catch (Exception e) {
        Debug.LogError($"Kino: Unable to save pack meta, exception: {e}");
        return false;
      }
    }
  }
}