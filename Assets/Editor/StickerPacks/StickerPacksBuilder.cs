using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using UnityEditor;
using UnityEngine;

// DO NOT EDIT THIS FILE
namespace Editor {
	public class StickerPacksBuilder : BaseBuilder<StickerPacksBuilderMeta, StickerPackMeta> {
		protected override void BuildPackBundle(BuildTarget target, StickerPacksBuilderMeta builder, AuthorMeta author, StickerPackMeta pack) {
			Debug.Log($"Kino: Processing pack '{pack.Name}'");

			string packFileName = $"{pack.Name}{builder.Ext}";

			string packRootFolder = pack.GetRoot();

			var meta = pack.GetProxyMeta();
			if (meta == null) {
				Debug.LogError($"Kino: Unable to build pack '{pack.Name}', failed to create metadata");
				return;
			}

			if (string.IsNullOrWhiteSpace(meta.IconName)) {
				Debug.LogError($"Kino: Empty pack icon path for '{pack.Name}'");
				return;
			}

			meta.AuthorName = author.Name;

			if (!SaveProxyMetaToTxt(packRootFolder, meta)) {
				Debug.LogError($"Kino: Unable to build pack '{pack.Name}', failed to create metadata");
				return;
			}

			AssetDatabase.Refresh();

			var assets = new List<string> {
				Path.Combine(packRootFolder, StickerPackMeta.PACK_META_RESERVED_NAME),
				Path.Combine(packRootFolder, $"{meta.IconName}.png")
			};

			foreach (var image in meta.Images) {
				if (string.IsNullOrWhiteSpace(image.ImageName)) {
					Debug.LogWarning($"Kino: Skipped invalid image in '{meta.Name}'");
					continue;
				}

				assets.Add(Path.Combine(packRootFolder, $"{image.ImageName}.png"));
			}

			var builds = new[] {
				new AssetBundleBuild {
					assetBundleName = packFileName,
					assetNames = assets.ToArray()
				}
			};

			if (!Directory.Exists(builder.DefaultBuildFolder)) {
				Directory.CreateDirectory(builder.DefaultBuildFolder);
			}

			BuildPipeline.BuildAssetBundles(builder.DefaultBuildFolder, builds, BuildAssetBundleOptions.ForceRebuildAssetBundle, target);

			RunPostBuild(packFileName, builder, author, pack);
		}

		protected override bool Validate(AuthorMeta author, IReadOnlyCollection<StickerPackMeta> entries, out string error) {
			error = string.Empty;

			if (entries.Count == 0) {
				error = "Nothing to build";
				return false;
			}

			foreach (var pack in entries) {
				if (!pack.SelectedToBuild) {
					continue;
				}

				if (string.IsNullOrWhiteSpace(pack.Name)
				    || string.IsNullOrWhiteSpace(pack.EncryptionKey)
				    || string.IsNullOrWhiteSpace(pack.Description)) {
					error = "One of selected to build packs has empty fields";
					return false;
				}

				if (pack.Version <= 0) {
					error = $"Invalid pack version: {pack.Name} -> {pack.Version}";
					return false;
				}

				if (!pack.PackIcon) {
					error = "Pack icon is not set";
					return false;
				}
			}

			return true;
		}

		private void RunPostBuild(string fileName, StickerPacksBuilderMeta builder, AuthorMeta author, StickerPackMeta meta) {
			string srcFilePath = Path.Combine(builder.DefaultBuildFolder, fileName);
			string dstFilePath = Path.Combine(builder.BuildFolder, fileName);

			if (!File.Exists(srcFilePath)) {
				Debug.LogError($"Kino: Unable to locate sticker pack bundle at '{srcFilePath}'");
				return;
			}

			var encryptedData = EncryptBundle(srcFilePath, meta);
			if (encryptedData == null) {
				Debug.LogError($"Kino: Unable to encrypt sticker pack '{meta.Name}'");
				return;
			}

			using var fileStream = new FileStream(dstFilePath, FileMode.Create);
			using var writer = new BinaryWriter(fileStream);

			writer.Write(builder.Version);
			writer.Write(meta.Version);
			writer.Write(author.SteamId);
			writer.Write(author.DiscordId);
			writer.Write(encryptedData.Length);
			writer.Write(encryptedData);
		}

		private byte[] EncryptBundle(string filePath, StickerPackMeta meta) {
			var key = ProcessEncryptionKey(meta.EncryptionKey);

			var fileContent = File.ReadAllBytes(filePath);

			using var aesAlg = Aes.Create();
			aesAlg.Key = key.Item1;
			aesAlg.IV = key.Item2;

			using var msEncrypt = new MemoryStream();
			using (var csEncrypt = new CryptoStream(msEncrypt, aesAlg.CreateEncryptor(), CryptoStreamMode.Write)) {
				csEncrypt.Write(fileContent, 0, fileContent.Length);
				csEncrypt.FlushFinalBlock();
			}

			return msEncrypt.ToArray();
		}

		private (byte[], byte[]) ProcessEncryptionKey(string encodedKey) {
			if (string.IsNullOrWhiteSpace(encodedKey)) {
				Debug.LogError("Kino: Unable to process empty key string");
				return (null, null);
			}

			var parts = encodedKey.Split('|');
			if (parts.Length != 2) {
				Debug.LogError("Kino: Bad key string");
				return (null, null);
			}

			var key = Convert.FromBase64String(parts[0]);
			var iv = Convert.FromBase64String(parts[1]);

			return (key, iv);
		}

		private bool SaveProxyMetaToTxt(string packRoot, StickerPackMeta.Proxy meta) {
			if (string.IsNullOrWhiteSpace(packRoot) || meta == null) {
				return false;
			}

			try {
				string json = JsonUtility.ToJson(meta, true);

				using var stream = new FileStream(Path.Combine(packRoot, StickerPackMeta.PACK_META_RESERVED_NAME), FileMode.Create, FileAccess.Write);
				using var writer = new StreamWriter(stream, Encoding.UTF8);
				writer.Write(json);

				return true;
			}
			catch (Exception e) {
				Debug.LogError($"Kino: Unable to save pack meta, exception: {e}");
				return false;
			}
		}
	}
}