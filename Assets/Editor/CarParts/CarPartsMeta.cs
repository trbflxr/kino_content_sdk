using System;
using System.Collections.Generic;
using System.Threading;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

// DO NOT EDIT THIS FILE
namespace Editor {
	public enum PackType {
		Undefined = 0,
		Wheels,
		UniversalInteriorParts,
		CarParts
	}

	public enum PartType {
		Undefined = 0,
		Wheel,
		SteeringWheel,
		Handbrake,
		ShifterSequential,
		ShifterHPattern,
		SeatLeft,
		SeatRight,
		BumperFront,
		BumperRear,
		Skirts,
		Doors,
		Mirrors,
		Bonnet,
		Trunk,
		Spoiler,
		Roof,
		Exhaust,
		Cage,
		LightsFront,
		LightsRear,
		Interior,
		Chassis
	}

	[Flags]
	public enum SlotType {
		BumperFront = 1 << 0,
		Bonnet = 1 << 1,
		Spoiler = 1 << 2,
		BumperRear = 1 << 3,
		Doors = 1 << 4,
		Roof = 1 << 5,
		Mirrors = 1 << 6,
		Trunk = 1 << 7,
		LightsFront = 1 << 8,
		LightsRear = 1 << 9,
		Exhaust = 1 << 10,
		Cage = 1 << 11,
		Skirts = 1 << 12,

		All = BumperFront | Bonnet | Spoiler | BumperRear | Doors | Roof | Mirrors | Trunk | LightsFront | LightsRear | Exhaust | Cage | Skirts

		// system flags below, max value have to be 25

		// Interior = 1 << 26,
		// SeatLeft = 1 << 27,
		// SeatRight = 1 << 28,
		// SteeringWheel = 1 << 29,
		// Handbrake = 1 << 30,
		// Shifter = 1 << 31,
	}

	[Serializable]
	public class SlotEntry {
		public SlotType Type;
		public int PartId = 0;
	}

	[Serializable]
	public class PartMeta {
		[Serializable]
		public class Proxy {
			public int Type;
			public int Id;
			public int ReplacementId;
			public string FilePath;
			public string IconPath;

			public float SteeringWheelSize;

			public bool IsPopups;
			public bool OverrideHeadlightsMask;
			public bool OverrideTurnSignals;
			public bool OverrideBrakeLight;

			public string CarNameOverride;
			public int EnabledParts;
			public float FrontTrackWidth;
			public float RearTrackWidth;
			public float FrontBaseZ;
			public float RearBaseZ;
			public float HeightOffset;
			public int[] DefaultParts;
		}

		[Tooltip("Type of part.\n"
		         + "Must match the type of the pack.")]
		public PartType Type = PartType.Undefined;

		[Tooltip("Part prefab, can't be null")]
		public GameObject Prefab;

		[Tooltip("[Optional] Part icon.\n"
		         + "It will be displayed on the card in the part selector in the game.")]
		public Texture2D Icon;

		[Tooltip("[Optional] ID of the vanilla part that closely resembles this one.\n"
		         + "This part will be displayed instead of the custom one for users who do not have this pack installed.")]
		public int ReplacementId;


		[Range(0.05f, 0.4f)]
		[Tooltip("Steering wheel size.\n"
		         + "Set the exact size for the animation to work correctly in the game.")]
		public float SteeringWheelSize = 0.3f;


		// [Tooltip("Consider this lights as popups")]
		// public bool IsPopups = false;

		[Tooltip("Set to TRUE if you want to disable the default hazard light sources from Kino.\n"
		         + "It is recommended to enable the override and configure custom light sources for a better appearance.")]
		public bool OverrideTurnSignals = false;

		[Tooltip("If TRUE is set, a custom mask (light cookie) will be used instead of the in-game mask for the headlights, if one is provided.")]
		public bool OverrideHeadlightsMask;

		[Tooltip("Set to TRUE if you want to hide the default brake light source from CarX.")]
		public bool OverrideBrakeLight;


		[Tooltip("[Optional] Specify the car name to be displayed")]
		public string CarNameOverride = string.Empty;

		[Tooltip("Specify which parts can be installed on the bodykit")]
		public SlotType EnabledParts = SlotType.All;

		[Range(0.1f, 2.5f)]
		public float FrontTrackWidth = 1.5f;

		[Range(0.1f, 2.5f)]
		public float RearTrackWidth = 1.5f;

		[Range(-1.0f, 1.0f)]
		public float FrontBaseZ = 0.0f;

		[Range(-1.0f, 1.0f)]
		public float RearBaseZ = 0.0f;

		[Range(-1.0f, 1.0f)]
		public float HeightOffset = 0.0f;

		[Tooltip("Specify the parts that will be applied by default when selecting a bodykit")]
		public List<SlotEntry> DefaultParts = new();

		[ReadOnly]
		[HideInInspector]
		public int Id;
		[HideInInspector]
		public string Name = "unknown";
		[HideInInspector]
		public string FilePath = string.Empty;

		public void Validate(bool forceRegenerateId) {
			if (Prefab) {
				Name = Prefab.name;
				FilePath = AssetDatabase.GetAssetPath(Prefab);
			}
			else {
				Name = "unknown";
			}

			if (forceRegenerateId || Id == 0) {
				Id = Utils.GetId();
			}
		}
	}

	[CreateAssetMenu(fileName = "__meta", menuName = "Kino/Create car parts pack meta", order = 1)]
	public class CarPartsMeta : BaseEntryMeta<CarPartsMeta> {
		[Serializable]
		public class Proxy {
			public ulong Id;
			public int Type;
			public int TargetCarId;
			public string AuthorName;
			public string Name;
			public string CategoryName;
			public string Description;
			public string PackIcon;
			public int Version;
			public bool AllowPartsDump;

			public List<PartMeta.Proxy> Parts;
		}

		public const string PACK_META_RESERVED_NAME = "__pack_meta.txt";

		[ReadOnly]
		[Tooltip("Pack unique ID")]
		public ulong Id = Utils.GenerateUniqueId();

		[Tooltip("Type of parts in the pack")]
		public PackType Type = PackType.Undefined;

		[HideInInspector]
		[Tooltip("Car ID for which the pack is intended")]
		public int TargetCarId = -1;

		[Tooltip("[Optional] Category name.\n"
		         + "It will be displayed on the card in the part selector in the game.\n"
		         + "Parts with the same category name will be grouped in one list, even if they are from different packs.")]
		public string CategoryName = "kino";

		[TextArea(4, 20)]
		[Tooltip("Pack description")]
		public string Description = string.Empty;

		[Tooltip("[Optional] Pack icon.\n"
		         + "It will be displayed on the category card in the part selector in the game.")]
		public Texture2D PackIcon;

		[Tooltip("Pack version")]
		public int Version = 100;

		[Tooltip("Will it be possible to dump parts using the Kino Car dumper?\n"
		         + "We recommend allowing dumping since it's necessary for livery creators to access the full model")]
		public bool AllowPartsDump = true;

		public List<PartMeta> Parts;

		private bool valid_;

		public Proxy GetProxyMeta() {
			var meta = new Proxy {
				Id = Id,
				Type = (int) Type,
				TargetCarId = TargetCarId,
				Name = Name,
				CategoryName = CategoryName,
				Version = Version,
				Description = Description,
				PackIcon = string.Empty,
				AllowPartsDump = AllowPartsDump,
				Parts = new List<PartMeta.Proxy>()
			};

			if (Parts == null) {
				return null;
			}

			if (PackIcon) {
				meta.PackIcon = AssetDatabase.GetAssetPath(PackIcon);
			}

			foreach (var part in Parts) {
				if (Type == PackType.Wheels && part.Type != PartType.Wheel) {
					Debug.LogError($"Kino: Unable to add part {part.Name} ({part.Type}), because pack type is different: {Type}");
					continue;
				}

				var partMeta = new PartMeta.Proxy {
					Type = (int) part.Type,
					FilePath = part.FilePath,
					IconPath = string.Empty,
					Id = part.Id,
					ReplacementId = part.ReplacementId,

					SteeringWheelSize = part.SteeringWheelSize,

					// IsPopups = part.IsPopups,
					OverrideHeadlightsMask = part.OverrideHeadlightsMask,
					OverrideTurnSignals = part.OverrideTurnSignals,
					OverrideBrakeLight = part.OverrideBrakeLight,

					CarNameOverride = part.CarNameOverride,
					EnabledParts = (int) part.EnabledParts,
					FrontTrackWidth = part.FrontTrackWidth,
					RearTrackWidth = part.RearTrackWidth,
					FrontBaseZ = part.FrontBaseZ,
					RearBaseZ = part.RearBaseZ,
					HeightOffset = part.HeightOffset,
					DefaultParts = new int[part.DefaultParts.Count]
				};

				for (int i = 0; i < part.DefaultParts.Count; ++i) {
					partMeta.DefaultParts[i] = part.DefaultParts[i].PartId;
				}

				if (string.IsNullOrWhiteSpace(partMeta.FilePath)) {
					continue;
				}

				if (part.Icon) {
					partMeta.IconPath = AssetDatabase.GetAssetPath(part.Icon);
				}

				meta.Parts.Add(partMeta);
			}

			return meta;
		}

		public override bool Validate() {
			if (Parts == null) {
				return false;
			}

			Debug.Log($"Kino: Validating parts list {Name} ({Type})");

			OnValidate();

			return valid_;
		}

		private void OnValidate() {
			valid_ = false;

			if (Type == PackType.Undefined) {
				Debug.LogWarning($"Kino: Invalid pack type selected: {Type}");
				return;
			}

			if (Type == PackType.CarParts && TargetCarId <= 0) {
				Debug.LogWarning($"Kino: Invalid target car ID selected: {TargetCarId}");
				return;
			}

			if (Parts == null) {
				return;
			}

			valid_ = true;

			// really dirty way to generate id
			for (var i = 0; i < Parts.Count; ++i) {
				var part = Parts[i];
				part.Validate(false);

				int index = Parts.FindIndex(p => p.Id == part.Id);
				if (index != -1 && index != i) {
					part.Validate(true);
					if (part.Id == Parts[index].Id) {
						Thread.Sleep(1000);
						part.Validate(true);
					}
				}

				if (part.Type == PartType.Undefined) {
					Debug.LogWarning($"Kino: Part {part.Name} has {part.Type} type selected");
					valid_ = false;
				}

				bool isWheel = part.Type == PartType.Wheel;
				bool isInterior = IsInteriorPart(part.Type);
				bool isExterior = IsExteriorPart(part.Type);

				if ((Type == PackType.Wheels && !isWheel)
				    || (Type == PackType.UniversalInteriorParts && !isInterior)
				    || (Type == PackType.CarParts && !isExterior)) {
					Debug.LogWarning($"Kino: Part {part.Name} ({part.Type}) is incompatible with pack {Name} ({Type}), because of type difference");
					valid_ = false;
				}

				if (!part.Prefab) {
					Debug.LogWarning($"Kino: Prefab is not set for part {part.Id} ({part.Type})");
					valid_ = false;
				}
			}
		}

		private bool IsExteriorPart(PartType type) {
			return type != PartType.Wheel && !IsInteriorPart(type);
		}

		private bool IsInteriorPart(PartType type) {
			switch (type) {
				case PartType.SteeringWheel:
				case PartType.Handbrake:
				case PartType.ShifterSequential:
				case PartType.ShifterHPattern:
				case PartType.SeatLeft:
				case PartType.SeatRight:
					return true;
			}

			return false;
		}
	}

	[CustomEditor(typeof(CarPartsMeta))]
	public class PartPackMetaEditor : BaseMetaEditor<CarPartsMeta> {
		private ReorderableList partsList_;
		private SerializedProperty partsProp_;

		public PartPackMetaEditor() : base(false) { }

		private void OnEnable() {
			partsProp_ = serializedObject.FindProperty("Parts");

			partsList_ = new ReorderableList(serializedObject, partsProp_, true, true, true, true) {
				drawHeaderCallback = rect => {
					GUI.Label(rect, "Parts");
				},
				drawElementCallback = (rect, index, _, _) => {
					var element = partsProp_.GetArrayElementAtIndex(index);
					EditorGUI.PropertyField(rect, element, GUIContent.none);
				},
				elementHeightCallback = index => {
					var element = partsProp_.GetArrayElementAtIndex(index);
					return EditorGUI.GetPropertyHeight(element, true) + EditorGUIUtility.standardVerticalSpacing;
				}
			};
		}

		public override void OnInspectorGUI() {
			var script = (CarPartsMeta) target;

			serializedObject.Update();

			EditorGUILayout.LabelField("Each field has a tooltip. Hold the cursor over it to see the tooltip.", EditorStyles.boldLabel);

			DrawProp("Id");
			DrawProp("Type");

			if (script.Type == PackType.CarParts) {
				DrawProp("TargetCarId", "Target car ID");
			}

			DrawProp("Name");
			DrawProp("CategoryName");
			DrawProp("Description");
			DrawProp("PackIcon");
			DrawProp("Version");

			if (script.Type == PackType.CarParts) {
				DrawProp("AllowPartsDump");
			}

			partsList_?.DoLayoutList();

			base.OnInspectorGUI();
		}
	}

	[CustomPropertyDrawer(typeof(PartMeta))]
	public class PartMetaDrawer : PropertyDrawer {
		private class State {
			public bool Foldout = false;
			public float Height = EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
			public bool SlotsVisible = false;
		}

		private static readonly Dictionary<string, State> states_ = new();

		private readonly float offset_ = EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {
			var state = GetOrAddState(property);
			return state.Foldout ? state.Height : EditorGUIUtility.singleLineHeight;
		}

		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {
			const float DRAG_OFFSET = 12.0f;

			EditorGUI.BeginProperty(position, label, property);

			string title = "unknown";
			var partType = PartType.Undefined;

			var prefabProp = property.FindPropertyRelative("Prefab");
			if (prefabProp?.objectReferenceValue) {
				title = prefabProp.objectReferenceValue.name;
			}

			var typeProp = property.FindPropertyRelative("Type");
			if (typeProp != null) {
				partType = (PartType) typeProp.intValue;
			}

			var foldoutLabel = new GUIContent($"{partType} ({title})");
			var foldoutRect = new Rect(position.x + DRAG_OFFSET, position.y, position.width, EditorGUIUtility.singleLineHeight);

			var state = GetOrAddState(property);
			state.Foldout = EditorGUI.Foldout(foldoutRect, state.Foldout, foldoutLabel, true);

			if (state.Foldout) {
				float x = position.x;
				float y = position.y;
				float width = position.width;

				DrawProperty(ref x, ref y, width, typeProp);
				DrawProperty(ref x, ref y, width, prefabProp);
				DrawProperty(ref x, ref y, width, property, "Icon");
				DrawProperty(ref x, ref y, width, property, "ReplacementId");

				if (partType is PartType.SteeringWheel) {
					DrawProperty(ref x, ref y, width, property, "SteeringWheelSize");
				}

				if (partType is PartType.LightsFront or PartType.LightsRear) {
					DrawProperty(ref x, ref y, width, property, "OverrideTurnSignals");
				}
				if (partType is PartType.LightsFront) {
					// DrawProperty(ref x, ref y, width, property, "IsPopups");
					DrawProperty(ref x, ref y, width, property, "OverrideHeadlightsMask");
				}
				if (partType is PartType.LightsRear) {
					DrawProperty(ref x, ref y, width, property, "OverrideBrakeLight");
				}

				if (partType is PartType.Chassis) {
					DrawProperty(ref x, ref y, width, property, "CarNameOverride");

					var partsProp = property.FindPropertyRelative("DefaultParts");

					EditorGUI.BeginChangeCheck();
					var enabledPartsProp = DrawProperty(ref x, ref y, width, property, "EnabledParts");
					if (EditorGUI.EndChangeCheck()) {
						UpdateSlots((SlotType) enabledPartsProp.intValue, partsProp);
					}

					DrawProperty(ref x, ref y, width, property, "FrontTrackWidth");
					DrawProperty(ref x, ref y, width, property, "RearTrackWidth");
					DrawProperty(ref x, ref y, width, property, "FrontBaseZ");
					DrawProperty(ref x, ref y, width, property, "RearBaseZ");
					DrawProperty(ref x, ref y, width, property, "HeightOffset");

					y += offset_;

					var foldoutPartsRect = new Rect(x + DRAG_OFFSET, y, position.width, EditorGUIUtility.singleLineHeight);
					state.SlotsVisible = EditorGUI.Foldout(foldoutPartsRect, state.SlotsVisible, new GUIContent("Default parts"), true);
					if (state.SlotsVisible) {
						for (int i = 0; i < partsProp.arraySize; ++i) {
							var slotProp = partsProp.GetArrayElementAtIndex(i);
							if (slotProp == null) {
								continue;
							}

							var slotTypeProp = slotProp.FindPropertyRelative("Type");
							var slotIdProp = slotProp.FindPropertyRelative("PartId");

							var slotType = (SlotType) slotTypeProp.intValue;
							if (slotType == SlotType.All) {
								continue;
							}

							float slotWidth = position.width - DRAG_OFFSET;
							var slotLabel = new GUIContent(slotType.ToString());

							y += offset_;
							EditorGUI.PropertyField(new Rect(x + DRAG_OFFSET, y, slotWidth, EditorGUIUtility.singleLineHeight), slotIdProp, slotLabel);
						}
					}
				}

				y += offset_;
				state.Height = y - position.y;
			}

			EditorGUI.EndProperty();
		}

		SerializedProperty DrawProperty(ref float x, ref float y, float width, SerializedProperty property, string propName) {
			var prop = property.FindPropertyRelative(propName);
			return DrawProperty(ref x, ref y, width, prop);
		}

		SerializedProperty DrawProperty(ref float x, ref float y, float width, SerializedProperty property) {
			y += offset_;

			var rect = new Rect(x, y, width, EditorGUIUtility.singleLineHeight);
			EditorGUI.PropertyField(rect, property, true);

			return property;
		}

		private State GetOrAddState(SerializedProperty property) {
			if (!states_.TryGetValue(property.propertyPath, out var state)) {
				state = new State();
				states_[property.propertyPath] = state;
			}

			return state;
		}

		private void UpdateSlots(SlotType slots, SerializedProperty slotsProperty) {
			var toAdd = slots;
			var toRemove = new List<int>();

			for (int i = 0; i < slotsProperty.arraySize; ++i) {
				var slotProp = slotsProperty.GetArrayElementAtIndex(i);
				if (slotProp == null) {
					continue;
				}

				var slotTypeProp = slotProp.FindPropertyRelative("Type");
				var slotType = (SlotType) slotTypeProp.intValue;

				if (slots.HasFlag(slotType)) {
					toAdd &= ~slotType;
				}
				else {
					toRemove.Add(i);
				}
			}

			int deleteOffset = 0;
			foreach (var index in toRemove) {
				slotsProperty.DeleteArrayElementAtIndex(index - deleteOffset++);
			}

			foreach (SlotType st in Enum.GetValues(typeof(SlotType))) {
				if (st is SlotType.All) {
					continue;
				}

				if (toAdd.HasFlag(st)) {
					slotsProperty.InsertArrayElementAtIndex(slotsProperty.arraySize);

					var newElement = slotsProperty.GetArrayElementAtIndex(slotsProperty.arraySize - 1);
					newElement.FindPropertyRelative("Type").intValue = (int) st;
					newElement.FindPropertyRelative("PartId").intValue = 0;
				}
			}
		}
	}
}